<?php

declare(strict_types=1);

namespace ReportedIp\Honeypot\Detection\Analyzers;

use ReportedIp\Honeypot\Core\Request;
use ReportedIp\Honeypot\Detection\AnalyzerInterface;
use ReportedIp\Honeypot\Detection\DetectionResult;
use ReportedIp\Honeypot\Detection\PatternLibrary;

/**
 * Detects known CVE exploit probes and common vulnerability scanning patterns.
 *
 * Covers Log4Shell, Spring4Shell, ThinkPHP RCE, PHPUnit RCE, Shellshock,
 * remote/local file inclusion, server-side template injection, webshell
 * probes, and WordPress REST API enumeration.
 */
final class VulnerabilityProbeAnalyzer implements AnalyzerInterface
{
    public function getName(): string
    {
        return 'VulnerabilityProbe';
    }

    public function analyze(Request $request): ?DetectionResult
    {
        $findings = [];
        $maxScore = 0;

        // Collect all inputs for scanning
        $targets = $this->collectTargets($request);

        // Check CVE patterns
        $cvePatterns = PatternLibrary::cvePatterns();
        foreach ($targets as $label => $value) {
            if ($value === '' || mb_strlen($value) < 4) {
                continue;
            }

            $decoded = $this->deepDecode($value);

            foreach ($cvePatterns as $pattern) {
                if (preg_match($pattern, $value) || preg_match($pattern, $decoded)) {
                    $description = $this->describeCve($pattern);
                    $score = $this->scoreCve($pattern);
                    $findings[] = sprintf('%s in %s', $description, $label);
                    $maxScore = max($maxScore, $score);
                    break;
                }
            }
        }

        // Check shell patterns
        $shellPatterns = PatternLibrary::shellPatterns();
        foreach ($targets as $label => $value) {
            if ($value === '' || mb_strlen($value) < 4) {
                continue;
            }

            $decoded = $this->deepDecode($value);

            foreach ($shellPatterns as $pattern) {
                if (preg_match($pattern, $value) || preg_match($pattern, $decoded)) {
                    $description = $this->describeShell($pattern);
                    $score = $this->scoreShell($pattern);
                    $findings[] = sprintf('%s in %s', $description, $label);
                    $maxScore = max($maxScore, $score);
                    break;
                }
            }
        }

        // Check Shellshock in headers
        $this->checkShellshock($request, $findings, $maxScore);

        // Check remote/local file inclusion in parameters
        $this->checkFileInclusion($request, $findings, $maxScore);

        // Check server-side template injection
        $this->checkSsti($request, $findings, $maxScore);

        // Check for webshell command parameters
        $this->checkWebshellParams($request, $findings, $maxScore);

        if (empty($findings)) {
            return null;
        }

        $comment = sprintf(
            'Vulnerability exploit probe detected: %s',
            implode('; ', array_slice(array_unique($findings), 0, 3))
        );

        return new DetectionResult([15, 35], $comment, $maxScore, $this->getName());
    }

    /**
     * @return array<string, string>
     */
    private function collectTargets(Request $request): array
    {
        $targets = [];

        $targets['URI'] = $request->getUri();
        $targets['path'] = $request->getPath();
        $targets['body'] = $request->getBody();

        foreach ($request->getQueryParams() as $key => $val) {
            $targets["query param '{$key}'"] = is_string($val) ? $val : (string) $val;
        }

        foreach ($request->getPostData() as $key => $val) {
            $targets["POST field '{$key}'"] = is_string($val) ? $val : (string) $val;
        }

        // Headers that may carry exploit payloads
        $headerNames = [
            'User-Agent', 'Referer', 'Cookie', 'X-Forwarded-For',
            'X-Api-Version', 'Authorization', 'Content-Type', 'Accept',
        ];
        foreach ($headerNames as $name) {
            $val = $request->getHeader($name);
            if ($val !== null && $val !== '') {
                $targets["header '{$name}'"] = $val;
            }
        }

        return $targets;
    }

    private function checkShellshock(Request $request, array &$findings, int &$maxScore): void
    {
        $headers = $request->getHeaders();
        $shellshockPattern = '/\(\)\s*\{\s*:;\s*\}\s*;/';

        foreach ($headers as $name => $value) {
            $headerVal = is_array($value) ? implode(', ', $value) : (string) $value;
            if (preg_match($shellshockPattern, $headerVal)) {
                $findings[] = sprintf('Shellshock exploit (CVE-2014-6271) in header "%s"', $name);
                $maxScore = max($maxScore, 95);
                return;
            }
        }
    }

    private function checkFileInclusion(Request $request, array &$findings, int &$maxScore): void
    {
        $params = array_merge($request->getQueryParams(), $request->getPostData());

        foreach ($params as $key => $value) {
            if (!is_string($value) || $value === '') {
                continue;
            }

            $decoded = $this->deepDecode($value);

            // Remote File Inclusion (RFI)
            if (preg_match('/^https?:\/\//i', $decoded) || preg_match('/^ftp:\/\//i', $decoded)) {
                // Check if this looks like a file inclusion parameter
                $inclusionParams = ['page', 'file', 'path', 'include', 'inc', 'template', 'tmpl', 'module', 'view', 'action', 'lang', 'language'];
                if (in_array(strtolower($key), $inclusionParams, true)) {
                    $findings[] = sprintf('Remote file inclusion via "%s" parameter', $key);
                    $maxScore = max($maxScore, 85);
                }
            }

            // Local File Inclusion (LFI) via PHP wrappers
            if (preg_match('/^(php:\/\/filter|php:\/\/input|data:\/\/|expect:\/\/)/i', $decoded)) {
                $findings[] = sprintf('Local file inclusion via PHP wrapper in "%s" parameter', $key);
                $maxScore = max($maxScore, 90);
            }
        }
    }

    private function checkSsti(Request $request, array &$findings, int &$maxScore): void
    {
        $params = array_merge($request->getQueryParams(), $request->getPostData());
        $sstiPatterns = [
            '/\{\{7\*7\}\}/' => 'Jinja2/Twig SSTI probe ({{7*7}})',
            '/\$\{7\*7\}/' => 'Java EL SSTI probe (${7*7})',
            '/#\{7\*7\}/' => 'Ruby ERB SSTI probe (#{7*7})',
            '/\{\{.*?__class__.*?\}\}/i' => 'Python SSTI class traversal',
            '/\{\{.*?config.*?\}\}/i' => 'SSTI config access',
            '/\$\{T\(java\.lang/i' => 'Spring EL SSTI',
        ];

        foreach ($params as $key => $value) {
            if (!is_string($value) || $value === '') {
                continue;
            }

            $decoded = $this->deepDecode($value);

            foreach ($sstiPatterns as $pattern => $description) {
                if (preg_match($pattern, $value) || preg_match($pattern, $decoded)) {
                    $findings[] = sprintf('%s in "%s" parameter', $description, $key);
                    $maxScore = max($maxScore, 80);
                    break;
                }
            }
        }
    }

    private function checkWebshellParams(Request $request, array &$findings, int &$maxScore): void
    {
        $params = $request->getQueryParams();
        $shellParams = ['cmd', 'exec', 'command', 'execute', 'run', 'shell', 'system', 'passthru', 'eval'];

        foreach ($shellParams as $param) {
            $value = $params[$param] ?? null;
            if ($value !== null && is_string($value) && $value !== '') {
                $findings[] = sprintf('Webshell command parameter "%s" with value', $param);
                $maxScore = max($maxScore, 90);
                break;
            }
        }
    }

    private function deepDecode(string $value, int $depth = 3): string
    {
        $decoded = $value;
        for ($i = 0; $i < $depth; $i++) {
            $next = urldecode($decoded);
            if ($next === $decoded) {
                break;
            }
            $decoded = $next;
        }
        return $decoded;
    }

    private function describeCve(string $pattern): string
    {
        $map = [
            'jndi' => 'Log4Shell exploit probe (CVE-2021-44228)',
            'lower|upper.*j' => 'Log4Shell obfuscated variant',
            'env|sys|java|main' => 'Log4Shell JNDI lookup variant',
            'classLoader' => 'Spring4Shell exploit probe (CVE-2022-22965)',
            'think|invokefunction' => 'ThinkPHP RCE exploit probe',
            'phpunit.*eval-stdin' => 'PHPUnit RCE exploit (CVE-2017-9841)',
            '%\{' => 'Apache Struts OGNL injection (CVE-2017-5638)',
            '\(\)\s*\{' => 'Shellshock exploit (CVE-2014-6271)',
            'wp-json.*users' => 'WordPress REST API user enumeration',
            'routestring' => 'vBulletin RCE probe (CVE-2019-16759)',
            'createpage-entervariables' => 'Confluence RCE probe (CVE-2021-26084)',
            'WEB-INF|META-INF' => 'Java application file disclosure',
            'tmui' => 'F5 BIG-IP RCE probe (CVE-2020-5902)',
            'autodiscover|mapi|ecp' => 'Exchange ProxyShell/ProxyLogon probe',
            'Runtime.*exec' => 'OGNL remote code execution',
        ];

        foreach ($map as $keyword => $description) {
            if (preg_match('/' . $keyword . '/i', $pattern)) {
                return $description;
            }
        }

        return 'Known CVE exploit probe';
    }

    private function scoreCve(string $pattern): int
    {
        // Critical RCE exploits
        if (preg_match('/jndi|classLoader|phpunit|think|invokefunction|Runtime.*exec|\(\)\s*\{/i', $pattern)) {
            return 95;
        }

        // Exchange/Confluence probes
        if (preg_match('/autodiscover|mapi|ecp|createpage/i', $pattern)) {
            return 85;
        }

        // Information disclosure
        if (preg_match('/wp-json.*users|WEB-INF|META-INF/i', $pattern)) {
            return 70;
        }

        // Struts
        if (preg_match('/%\{/i', $pattern)) {
            return 85;
        }

        return 75;
    }

    private function describeShell(string $pattern): string
    {
        $map = [
            'cmd|exec|command|execute|run|shell|system|passthru' => 'Webshell command parameter',
            'eval|assert|system|exec|shell_exec|passthru|popen|proc_open' => 'PHP code execution function',
            '`[^`]' => 'Backtick command execution',
            'c99shell|r57shell|b374k|wso|alfa|weevely|phpspy|ani.*shell' => 'Known webshell signature',
            'base64_decode' => 'Base64-encoded code execution',
            'file_put_contents|fwrite|move_uploaded_file' => 'File write attempt',
            'proc_open|pcntl_exec' => 'Process execution attempt',
            'bin\/(bash|sh)|nc\s|ncat|python.*socket|perl.*socket|ruby.*socket' => 'Reverse shell indicator',
        ];

        foreach ($map as $keyword => $description) {
            if (preg_match('/' . $keyword . '/i', $pattern)) {
                return $description;
            }
        }

        return 'Shell execution indicator';
    }

    private function scoreShell(string $pattern): int
    {
        // Known webshells
        if (preg_match('/c99shell|r57shell|b374k|wso|alfa|weevely/i', $pattern)) {
            return 95;
        }

        // Reverse shell
        if (preg_match('/bin\/(bash|sh)|nc\s|ncat|python.*socket/i', $pattern)) {
            return 90;
        }

        // Code execution functions
        if (preg_match('/eval|system|exec|shell_exec|passthru|popen|proc_open|pcntl_exec/i', $pattern)) {
            return 85;
        }

        // File operations
        if (preg_match('/file_put_contents|fwrite|move_uploaded_file/i', $pattern)) {
            return 80;
        }

        // Base64 encoded payloads
        if (preg_match('/base64_decode/i', $pattern)) {
            return 80;
        }

        return 70;
    }
}
