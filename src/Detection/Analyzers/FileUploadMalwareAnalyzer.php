<?php

declare(strict_types=1);

namespace ReportedIp\Honeypot\Detection\Analyzers;

use ReportedIp\Honeypot\Core\Request;
use ReportedIp\Honeypot\Detection\AnalyzerInterface;
use ReportedIp\Honeypot\Detection\DetectionResult;

/**
 * Detects malicious file upload attempts.
 *
 * Covers multipart form data uploads with dangerous file extensions,
 * double extension tricks, PHP code signatures in request body,
 * uploads to known WordPress upload endpoints, and MIME type spoofing.
 */
final class FileUploadMalwareAnalyzer implements AnalyzerInterface
{
    /** Dangerous file extensions that indicate malware upload attempts. */
    private const DANGEROUS_EXTENSIONS = [
        'php', 'phtml', 'php3', 'php4', 'php5', 'php7', 'phar',
        'jsp', 'asp', 'aspx', 'cgi',
        'exe', 'bat', 'scr', 'vbs', 'cmd', 'sh',
    ];

    /** Image extensions used in double-extension attacks. */
    private const IMAGE_EXTENSIONS = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'ico'];

    /** PHP code signatures indicating malicious payloads. */
    private const PHP_CODE_SIGNATURES = [
        '/<\?php/i',
        '/\beval\s*\(/i',
        '/\bbase64_decode\s*\(/i',
        '/\bshell_exec\s*\(/i',
        '/\bsystem\s*\(/i',
        '/\bpassthru\s*\(/i',
        '/\bexec\s*\(/i',
        '/\bproc_open\s*\(/i',
        '/\bpopen\s*\(/i',
        '/\bassert\s*\(/i',
    ];

    /** Known WordPress upload endpoint patterns. */
    private const UPLOAD_ENDPOINTS = [
        '#/wp-admin/async-upload\.php#i',
        '#/wp-admin/upload\.php#i',
    ];

    public function getName(): string
    {
        return 'FileUploadMalware';
    }

    public function analyze(Request $request): ?DetectionResult
    {
        if (!$request->isPost()) {
            return null;
        }

        $findings = [];
        $maxScore = 0;

        $contentType = $request->getContentType();
        $body = $request->getBody();
        $path = $request->getPath();

        $isMultipart = $contentType !== null && stripos($contentType, 'multipart/form-data') !== false;

        // Check for POST to known upload endpoints
        $this->checkUploadEndpoints($path, $isMultipart, $findings, $maxScore);

        // For multipart uploads, perform deeper analysis
        if ($isMultipart && $body !== '') {
            // Check for dangerous file extensions in body
            $this->checkDangerousExtensions($body, $findings, $maxScore);

            // Check for double extensions
            $this->checkDoubleExtensions($body, $findings, $maxScore);

            // Check for MIME type spoofing
            $this->checkMimeSpoofing($body, $findings, $maxScore);
        }

        // Check for PHP code signatures in any POST body
        if ($body !== '') {
            $this->checkPhpSignatures($body, $findings, $maxScore);
        }

        if (empty($findings)) {
            return null;
        }

        $comment = sprintf(
            'Malicious file upload detected: %s (path: %s)',
            implode('; ', array_slice(array_unique($findings), 0, 3)),
            substr($path, 0, 200)
        );

        return new DetectionResult([43], $comment, $maxScore, $this->getName());
    }

    private function checkUploadEndpoints(string $path, bool $isMultipart, array &$findings, int &$maxScore): void
    {
        foreach (self::UPLOAD_ENDPOINTS as $pattern) {
            if (preg_match($pattern, $path)) {
                if ($isMultipart) {
                    $findings[] = sprintf('File upload to WordPress upload endpoint: %s', $path);
                    $maxScore = max($maxScore, 75);
                } else {
                    $findings[] = sprintf('POST to WordPress upload endpoint: %s', $path);
                    $maxScore = max($maxScore, 70);
                }
                return;
            }
        }
    }

    private function checkDangerousExtensions(string $body, array &$findings, int &$maxScore): void
    {
        $extensionPattern = '/filename\s*=\s*["\']?[^"\';\r\n]*\.(' . implode('|', self::DANGEROUS_EXTENSIONS) . ')\b/i';

        if (preg_match($extensionPattern, $body, $matches)) {
            $findings[] = sprintf('Dangerous file extension in upload: .%s', strtolower($matches[1]));
            $maxScore = max($maxScore, 85);
        }
    }

    private function checkDoubleExtensions(string $body, array &$findings, int &$maxScore): void
    {
        // Build pattern for double extensions like .php.jpg, .phtml.png
        $dangerousExts = implode('|', self::DANGEROUS_EXTENSIONS);
        $imageExts = implode('|', self::IMAGE_EXTENSIONS);

        $doubleExtPattern = '/filename\s*=\s*["\']?[^"\';\r\n]*\.(' . $dangerousExts . ')\.(' . $imageExts . ')\b/i';

        if (preg_match($doubleExtPattern, $body, $matches)) {
            $findings[] = sprintf('Double extension attack: .%s.%s', strtolower($matches[1]), strtolower($matches[2]));
            $maxScore = max($maxScore, 90);
        }
    }

    private function checkPhpSignatures(string $body, array &$findings, int &$maxScore): void
    {
        $matchCount = 0;

        foreach (self::PHP_CODE_SIGNATURES as $pattern) {
            if (preg_match($pattern, $body)) {
                $matchCount++;
            }
        }

        if ($matchCount >= 3) {
            $findings[] = sprintf('Multiple PHP code signatures in upload body (%d matches)', $matchCount);
            $maxScore = max($maxScore, 90);
        } elseif ($matchCount >= 1) {
            $findings[] = 'PHP code signature in upload body';
            $maxScore = max($maxScore, 75);
        }
    }

    private function checkMimeSpoofing(string $body, array &$findings, int &$maxScore): void
    {
        // Check for Content-Type mismatch: claims to be image but filename is PHP
        $dangerousExts = implode('|', self::DANGEROUS_EXTENSIONS);

        // Content-Type says image/*, but filename has dangerous extension
        if (preg_match('/Content-Type:\s*image\//i', $body)
            && preg_match('/filename\s*=\s*["\']?[^"\';\r\n]*\.(' . $dangerousExts . ')\b/i', $body)
        ) {
            $findings[] = 'MIME type spoofing: image Content-Type with dangerous file extension';
            $maxScore = max($maxScore, 85);
        }

        // Content-Type says application/octet-stream with PHP extension
        if (preg_match('/Content-Type:\s*application\/octet-stream/i', $body)
            && preg_match('/filename\s*=\s*["\']?[^"\';\r\n]*\.php\b/i', $body)
        ) {
            $findings[] = 'MIME type spoofing: octet-stream Content-Type with PHP extension';
            $maxScore = max($maxScore, 80);
        }
    }
}
